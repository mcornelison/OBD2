# Ralph Progress Log
# Project: Eclipse OBD-II Application Orchestration
# Branch: ralph/app-orchestration
# Started: 2026-01-23

## Codebase Patterns
- ConfigValidator uses dot-notation for nested key access (e.g., 'database.server')
- Default values are defined in module-level DEFAULTS dict
- Custom exceptions should include typed field lists for clear debugging
- All modules in src/common/ follow camelCase for functions, PascalCase for classes
- Test files use AAA pattern (Arrange, Act, Assert) with descriptive docstrings
- Use relative imports within subpackages (e.g., `from .types import ...`)
- Use absolute imports across subpackages (e.g., `from src.obd.data.types import ...`)
- Types modules should have no dependencies on other project modules
- Consider using `TYPE_CHECKING` for type hints to avoid runtime circular imports
- Preserve all docstrings and type hints during moves
- Package/module name collision: When foo/ package shadows foo.py module, use importlib.util
- When refactoring modules, test patches must be updated to reference the new module location
- Re-export facades maintain backward compatibility during subpackage refactoring

## Session Log

## 2026-01-23 - US-OSC-001
User Story: Implement Application Orchestrator Class
- What was implemented:
  - Created `src/obd/orchestrator.py` with ApplicationOrchestrator class
  - Central orchestrator manages lifecycle of all system components
  - Constructor accepts `config: dict` and `simulate: bool` parameters
  - Maintains references to 9 managed components (database, profileManager, connection, vinDecoder, displayManager, driveDetector, alertManager, statisticsEngine, dataLogger)
  - Provides `start()` method with dependency-ordered initialization
  - Provides `stop()` method with reverse-order shutdown
  - Provides `isRunning()` for state checking
  - Provides `getStatus()` returning dict with running state and component statuses
  - Error handling with custom exceptions: OrchestratorError, ComponentInitializationError, ComponentStartError, ComponentStopError
  - Created `createOrchestratorFromConfig()` factory function
  - Updated `src/obd/__init__.py` to export orchestrator classes
- Files changed:
  - src/obd/orchestrator.py (NEW - 550 lines)
  - src/obd/__init__.py (MODIFIED - added orchestrator exports)
  - tests/test_orchestrator.py (NEW - 21 tests)
  - ralph/prd.json (MODIFIED - marked US-OSC-001 as passes: true)
- **Learnings for future iterations:**
  - Component initialization order is critical: database must be first (all others depend on it)
  - Shutdown order is reverse of startup order
  - Use `hasattr()` checks before calling stop/disconnect methods since not all components have them
  - Components created via factory functions from config using existing patterns (createXxxFromConfig)
  - When testing start(), mock `_initializeAllComponents` to avoid full initialization chain
  - Test individual init methods separately for precise coverage
---

## 2026-01-23 - US-OSC-002
User Story: Implement Startup Sequence
- What was implemented:
  - Added `time` import and startup timing measurement
  - Added `DEFAULT_SHUTDOWN_TIMEOUT` constant (5.0 seconds)
  - Enhanced `start()` method with:
    - Startup time tracking (records start/end time)
    - Total startup time logged at completion: "startup_time=X.XXs"
    - KeyboardInterrupt (Ctrl+C) handling with cleanup
  - Enhanced `_initializeConnection()` to:
    - Call `connect()` on the connection object to use built-in retry logic
    - Utilize exponential backoff from config['bluetooth']['retryDelays']
    - Re-raise ComponentInitializationError without wrapping
  - Added 10 new tests covering startup sequence requirements:
    - TestStartupSequenceOrder: Verifies component initialization order
    - TestStartupLogging: Tests INFO/ERROR level logging
    - TestStartupTiming: Tests startup time logging
    - TestStartupAbort: Tests Ctrl+C handling and cleanup
    - TestStartupCleanup: Tests partial state cleanup on failure
    - TestConnectionRetry: Tests config retry settings usage
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - added timing, abort handling, connection retry)
  - tests/test_orchestrator.py (MODIFIED - added 10 new tests, now 31 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-002 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Connection objects already implement retry with exponential backoff - use `hasattr(obj, 'connect')` pattern
  - KeyboardInterrupt must be handled separately from Exception to allow proper re-raise
  - Use `time.time()` for simple timing, log with pipe-separated key=value format
  - Test initialization order by mocking each init method with a tracking function
  - When re-raising specific exceptions (like ComponentInitializationError), catch and re-raise before general Exception handler
---

## 2026-01-23 - US-OSC-003
User Story: Implement Shutdown Sequence
- What was implemented:
  - Added `signal`, `sys`, `threading` imports for shutdown handling
  - Created `ShutdownState` enum (RUNNING, SHUTDOWN_REQUESTED, FORCE_EXIT)
  - Added exit code constants: EXIT_CODE_CLEAN (0), EXIT_CODE_FORCED (1), EXIT_CODE_ERROR (2)
  - Enhanced `ApplicationOrchestrator.__init__()` with:
    - `_shutdownState`: Tracks current shutdown state
    - `_shutdownTimeout`: Configurable timeout from config['shutdown']['componentTimeout']
    - `_exitCode`: Tracks exit code for clean vs forced shutdown
    - `_originalSigintHandler` / `_originalSigtermHandler`: Store original signal handlers
  - Added signal handling methods:
    - `registerSignalHandlers()`: Registers SIGINT (Ctrl+C) and SIGTERM handlers
    - `restoreSignalHandlers()`: Restores original handlers on shutdown
    - `_handleShutdownSignal()`: First signal requests graceful shutdown, second forces immediate exit
  - Added `_stopComponentWithTimeout()` helper:
    - Uses `threading.Event` with timeout for non-blocking stop
    - Force-stops components that don't respond within timeout
    - Logs warnings for slow/errored components
    - Sets exit code to FORCED if timeout occurs
  - Enhanced `stop()` method:
    - Returns exit code (0=clean, 1=forced, 2=error)
    - Logs shutdown timing: "shutdown_time=X.XXs | exit_code=N"
    - Checks for force exit state before graceful shutdown
  - Updated shutdown order to include all components (reverse of init):
    dataLogger -> statisticsEngine -> alertManager -> driveDetector ->
    displayManager -> vinDecoder -> connection -> profileManager -> database
  - Added properties: `exitCode`, `shutdownState`
  - Added 21 new tests covering shutdown sequence requirements
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - added shutdown with timeouts, signal handling)
  - tests/test_orchestrator.py (MODIFIED - added 21 new tests, now 52 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-003 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Use `threading.Event` with `wait(timeout=)` for timeout-based operations
  - Use daemon threads (`daemon=True`) for non-blocking cleanup threads
  - Signal handlers should check state first - allows double-signal force exit pattern
  - SIGTERM not available on Windows - use `hasattr(signal, 'SIGTERM')` check
  - Connection components use `disconnect()` not `stop()` - pass custom `stopMethod` parameter
  - Database components often don't need explicit stop - they use context managers
  - Test signal handling by calling the handler directly, not by sending actual signals
  - Use `pytest.raises(SystemExit)` to test `sys.exit()` calls
---

## 2026-01-23 - US-OSC-004
User Story: Implement Signal Handlers
- What was implemented:
  - Updated `src/main.py` to integrate with ApplicationOrchestrator:
    - Updated `runWorkflow()` function signature: now takes `simulate: bool` parameter
    - Changed return type from `bool` to `int` (exit code)
    - Orchestrator signal handlers registered BEFORE starting orchestrator
    - Orchestrator signal handlers restored in `finally` block (even on error)
    - Main loop waits for shutdown signal by checking `orchestrator.shutdownState`
  - Added dry-run mode support (validates config without starting orchestrator)
  - Signal handling works correctly on both Windows and Linux:
    - SIGINT (Ctrl+C) registered on all platforms
    - SIGTERM only registered on Linux (checked with `hasattr(signal, 'SIGTERM')`)
    - Double Ctrl+C forces immediate exit via `sys.exit(EXIT_CODE_FORCED)`
  - Updated `main()` to pass `simulate` flag to `runWorkflow()`
  - Added 17 new tests to `tests/test_main.py`:
    - TestRunWorkflow: 3 tests for orchestrator integration
    - TestSignalHandlerIntegration: 4 tests for signal handler lifecycle
    - TestCrossPlatformSignalHandlers: 6 tests for cross-platform behavior
    - TestMain: 1 new test for simulate flag
- Files changed:
  - src/main.py (MODIFIED - integrated orchestrator with signal handling)
  - tests/test_main.py (MODIFIED - 17 new tests, now 41 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-004 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - When patching imports inside a function, patch at the actual module location (e.g., `obd.orchestrator.createOrchestratorFromConfig`) not at the calling module
  - Signal handler restoration must be in `finally` block to ensure cleanup even on exceptions
  - Use `type(mockObj).property = property(lambda self: value)` to mock property values on MagicMock objects
  - `runWorkflow()` should return exit code (int), not success boolean, for proper process exit handling
  - When changing function signatures, update all tests that call or mock that function
---

## 2026-01-23 - US-OSC-005
User Story: Implement Main Application Loop
- What was implemented:
  - Added `runLoop()` method to ApplicationOrchestrator for main application loop
  - Loop runs until shutdown signal received (checks `_shutdownState`)
  - Added `_setupComponentCallbacks()` to wire component events:
    - DriveDetector: `onDriveStart`, `onDriveEnd` callbacks
    - RealtimeDataLogger: `onReading`, `onError` callbacks
    - AlertManager: `onAlert` callback (if supported)
    - StatisticsEngine: `onComplete` callback (if supported)
  - Implemented `registerCallbacks()` for external callback registration
  - Added health check with configurable interval (default 60s):
    - `_performHealthCheck()` logs: connection status, data rate, error count, drives, alerts, uptime
    - `setHealthCheckInterval()` to update interval dynamically (min 10s)
    - `getHealthCheckStats()` returns current HealthCheckStats
  - Created `HealthCheckStats` dataclass for tracking stats
  - Connection monitoring with lost/restored events:
    - `_checkConnectionStatus()` checks if connection.isConnected()
    - `_handleConnectionLost()` and `_handleConnectionRestored()` handlers
    - Display updated with "Reconnecting..." / "Connected" status
  - Reading handler routes values to DriveDetector and AlertManager
  - Exception handling catches loop errors without crashing
  - Memory efficiency: No unbounded growth (stats are simple counters, no lists)
  - Updated main.py to use `orchestrator.runLoop()` instead of manual loop
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - added ~400 lines for main loop)
  - src/main.py (MODIFIED - simplified runWorkflow to use runLoop())
  - tests/test_orchestrator.py (MODIFIED - added 30 new tests, now 82 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-005 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Use `hasattr()` checks before calling component methods to handle optional features
  - Health check stats should use counters not lists to avoid memory growth
  - Callback errors should be logged and caught, not allowed to crash the loop
  - Initial connection check must happen outside the try-catch to properly setup state
  - When testing loops that wait for signals, use threading to trigger shutdown from another thread
---

## 2026-01-23 - US-OSC-006
User Story: Wire Up Realtime Data Logging
- What was implemented:
  - Added `_extractDashboardParameters()` method to extract parameter names with displayOnDashboard:true
  - Modified `_handleReading()` to send dashboard-eligible readings to displayManager.updateValue()
  - Added `_logDataLoggingRate()` method for logging records/minute every 5 minutes
  - Added `DEFAULT_DATA_RATE_LOG_INTERVAL` constant (300.0 seconds = 5 minutes)
  - Added `_dataRateLogInterval` config option via monitoring.dataRateLogIntervalSeconds
  - Added tracking variables: `_lastDataRateLogTime`, `_lastDataRateLogCount`, `_dashboardParameters`
  - Integrated data rate logging into runLoop() alongside health checks
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - added dashboard display updates, data rate logging)
  - tests/test_orchestrator.py (MODIFIED - added 18 new tests, now 100 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-006 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Use Set[str] for parameter name lookups to avoid O(n) list searches on every reading
  - Always check `hasattr()` before calling display methods - displayManager may not have updateValue()
  - Extract dashboard parameters once at init time, not on every reading for efficiency
  - Data rate logging should be separate from health checks - different intervals (5min vs 1min default)
  - When adding new config options, provide sensible defaults via constants
---

## 2026-01-23 - US-OSC-007
User Story: Wire Up Drive Detection
- What was implemented:
  - Verified existing DriveDetector wiring in ApplicationOrchestrator:
    - `_initializeDriveDetector()` creates DriveDetector from config with database and statisticsEngine
    - `_handleReading()` routes RPM and SPEED values to `driveDetector.processValue(paramName, value)`
    - `_setupComponentCallbacks()` registers `_handleDriveStart` and `_handleDriveEnd` callbacks
    - `_handleDriveStart()` logs event, updates display with 'driving' status, increments drivesDetected
    - `_handleDriveEnd()` logs event with duration, updates display with 'stopped' status
    - DriveDetector internally calls `statisticsEngine.scheduleAnalysis()` when `triggerAnalysisAfterDrive=true`
    - DriveDetector logs drive events to connection_log table via `_logDriveEvent()`
  - DriveDetector handles debounce via configurable duration thresholds:
    - `driveStartDurationSeconds`: RPM must stay above threshold for this duration
    - `driveEndDurationSeconds`: RPM must stay below threshold for this duration
  - Added 17 new tests for US-OSC-007 covering:
    - DriveDetector property access and config setup
    - RPM/SPEED routing to driveDetector.processValue()
    - Drive start callback logging and display updates
    - Drive end callback logging and display updates
    - Callback registration and error handling
    - DriveDetector start/stop in main loop
    - Debounce config verification
    - Database availability for session logging
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - added modification history entry)
  - tests/test_orchestrator.py (MODIFIED - added 17 new tests, now 117 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-007 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Drive detection wiring was already complete from previous stories (US-OSC-005, US-OSC-006)
  - DriveDetector handles analysis triggering internally - orchestrator callbacks are for external notifications
  - Drive events are logged to connection_log table with event_type='drive_start' or 'drive_end'
  - Debounce is handled by duration-based state machine in DriveDetector, not the orchestrator
  - When verifying existing implementations, write tests to document expected behavior
---

## 2026-01-23 - US-OSC-008
User Story: Wire Up Alert System
- What was implemented:
  - Fixed AlertManager callback registration in orchestrator.py:
    - Changed from `registerCallback(onAlert=...)` to `onAlert(...)` method
    - AlertManager uses `onAlert()` for single callback registration pattern
  - Enhanced `_handleAlert()` callback with detailed logging:
    - Logs at WARNING level with full alert details (type, param, value, threshold, profile)
    - Updates display via `displayManager.showAlert(alertEvent)`
    - Increments `alertsTriggered` health check stat
    - Invokes external callback if registered
  - Verified alert wiring flow:
    - AlertManager created in `_initializeAlertManager()` with config, database, displayManager
    - Values routed to AlertManager via `_handleReading()` -> `alertManager.checkValue()`
    - AlertManager handles database logging internally (`_logAlertToDatabase`)
    - Cooldown enforcement via `_cooldownSeconds` in AlertManager
    - Alert history queryable via `AlertManager.getAlertHistory()`
    - Profile thresholds loaded from config in `createAlertManagerFromConfig()`
  - Added 22 new tests to test_orchestrator.py covering:
    - AlertManager creation from config
    - Alert manager property access
    - Value passing to alert manager checkValue()
    - Callback registration with onAlert() method
    - Alert handler WARNING logging
    - Display integration and error handling
    - External callback invocation
    - Cooldown config pass-through
    - Database for alert history
    - AlertManager shutdown
    - Full alert flow integration
    - Detailed logging with full alert details
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - fixed alert callback, enhanced logging)
  - tests/test_orchestrator.py (MODIFIED - added 22 new tests, now 139 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-008 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - AlertManager uses `onAlert()` method to register callbacks, not `registerCallback()`
  - Check actual class method signatures before assuming patterns from other components
  - Database logging for alerts happens INSIDE AlertManager before callback is triggered
  - When patching imports inside functions, patch at the actual module location (e.g., `obd.alert_manager.X` not `obd.orchestrator.X`)
  - Alert flow: reading -> checkValue() -> AlertManager triggers callback -> orchestrator logs/displays
---

## 2026-01-23 - US-OSC-014
User Story: Update main.py with Orchestrator Integration
- What was implemented:
  - Verified existing orchestrator integration in main.py (already complete from US-OSC-004/005)
  - Added 3 new tests to test_main.py covering:
    - `test_runWorkflow_callsRunLoopAfterStart`: Verifies runLoop() called after start()
    - `test_runWorkflow_returnsExitCodeFromOrchestrator`: Verifies exit code returned
    - `test_runWorkflow_exitCodeErrorOnWorkflowException`: Verifies error handling
  - All 9 acceptance criteria verified:
    - runWorkflow() creates ApplicationOrchestrator instance (line 184)
    - Orchestrator receives parsed config and simulate flag (line 184)
    - orchestrator.start() called to begin operation (line 192)
    - Main thread waits for shutdown signal via runLoop() (line 196)
    - orchestrator.stop() called on shutdown (line 199)
    - Exit code reflects orchestrator status (return value from stop())
    - All existing CLI flags continue to work (verified by TestParseArgs tests)
    - --dry-run validates config without starting orchestrator (lines 176-179)
    - Typecheck passes (verified by project quality checks)
- Files changed:
  - tests/test_main.py (MODIFIED - added 3 new tests, now 44 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-014 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Implementation was already complete from earlier user stories (US-OSC-004, US-OSC-005)
  - For "wire-up" stories, verify existing code first before adding new implementation
  - When orchestrator integration exists, focus on test coverage gaps rather than new code
  - Test call order with side_effect list pattern: `side_effect=lambda: callOrder.append('name')`
  - Main.py uses EXIT_RUNTIME_ERROR constant for error exit codes (value 2)
---

## 2026-01-23 - US-OSC-015
User Story: Create Integration Test Suite
- What was implemented:
  - Created `tests/test_orchestrator_integration.py` with 27 comprehensive integration tests
  - Test classes organized by acceptance criteria:
    - `TestOrchestratorStartsInSimulatorMode` (3 tests): startup, database init, connection init
    - `TestOrchestratorStopsGracefully` (3 tests): stop(), signal handling, component cleanup
    - `TestDataLoggingDuringSimulatedDrive` (2 tests): database logging, health stats tracking
    - `TestDriveDetectionOnRpmChanges` (3 tests): RPM routing to detector, drive count, callbacks
    - `TestStatisticsAfterDriveEnd` (3 tests): drive end logging, callbacks, analysis complete notification
    - `TestAlertTriggersOnThresholdViolation` (4 tests): value routing, alert counting, WARNING logging, callbacks
    - `TestTemporaryDatabaseUsage` (2 tests): verify temp database, not production
    - `TestCompletionWithinTimeLimit` (2 tests): timing verification
    - `TestConnectionStateMonitoring` (2 tests): connection state, lost callback
    - `TestDashboardParameterRouting` (1 test): dashboard parameter extraction
    - `TestErrorHandlingDuringOperation` (2 tests): callback error handling, error tracking
  - Helper function `getIntegrationTestConfig(dbPath)` creates test configuration
  - Fixtures: `tempDb` for temporary database, `integrationConfig` for test config
  - All tests use temporary file-based database (not :memory:) for proper integration testing
  - Tests complete in 19.64s total (well under 60s requirement)
- Files changed:
  - tests/test_orchestrator_integration.py (NEW - 1044 lines, 27 tests)
  - ralph/prd.json (MODIFIED - marked US-OSC-015 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Use file-based temp databases (`tempfile.mkstemp(suffix='.db')`) not `:memory:` for integration tests
  - Integration tests should use `@pytest.mark.integration` marker for filtering
  - Use threading + daemon=True for running loop in background during tests
  - Mock internal methods (like `_handleReading`) to simulate component events in isolation
  - Create mock objects as nested classes within tests for clear, focused test setup
  - Always cleanup orchestrator with try/finally to ensure stop() is called
  - Health stats can be used to verify internal state changes during operation
  - Test callbacks by registering mock handlers and verifying invocation
---

## 2026-01-23 - US-OSC-020
User Story: End-to-End Simulator Test
- What was implemented:
  - Created comprehensive `docs/testing.md` with test procedures covering:
    - Quick start guide for unit tests and simulator mode
    - Step-by-step E2E simulator test procedure (7 verification steps)
    - Extended 5-minute continuous run test with success criteria table
    - Alert testing with custom threshold configuration
    - Statistics engine testing with quick-test config
    - Database verification queries (correct table names: realtime_data, profiles)
    - Troubleshooting section for common issues
    - Performance benchmarks table
    - Test automation script (bash) for automated testing
  - Verified all 10 acceptance criteria:
    1. Application starts with `python src/main.py --simulate` - Shows "SIMULATION MODE" banner
    2. Database created and initialized at ./data/obd.db
    3. Simulated connection established (with 2s delay)
    4. Data logging visible - 13 parameters at 1Hz polling
    5. Drive detection works - DRIVE STARTED logged when RPM > 500 for 10s
    6. Statistics engine initialized (generates on drive end)
    7. Graceful shutdown on Ctrl+C - exit code 0
    8. No errors in 70-second test run
    9. Database contains expected records - 130+ realtime_data rows, 2 profiles
    10. docs/testing.md created with procedures
- Files changed:
  - docs/testing.md (NEW - 450+ lines)
  - ralph/prd.json (MODIFIED - marked US-OSC-020 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Database table is named `realtime_data` not `obd_readings` - check schema before writing queries
  - Simulated connection has configurable delay (default 2s) for realistic startup timing
  - Drive detection triggers at idle RPM (~800) because idle > threshold (500) - may need to adjust test config
  - ProfileManager creates/updates profiles in database automatically on startup
  - Health check fires every 60s by default, data rate log every 5 minutes
  - Integration tests pass in ~24s (27 tests), full suite in ~39s (505 tests)
  - Use `timeout` command on bash to run timed tests, exit code 124 on timeout
---

## 2026-01-23 - US-OSC-009
User Story: Wire Up Statistics Engine
- What was implemented:
  - Fixed initialization order in ApplicationOrchestrator:
    - Moved statisticsEngine initialization BEFORE driveDetector
    - DriveDetector needs statisticsEngine to trigger post-drive analysis
    - Old order: displayManager → driveDetector → alertManager → statisticsEngine
    - New order: displayManager → statisticsEngine → driveDetector → alertManager
  - Fixed callback registration for StatisticsEngine:
    - Changed from `registerCallback(onComplete=...)` to `registerCallbacks(onAnalysisComplete=..., onAnalysisError=...)`
    - StatisticsEngine uses different callback interface than other components
  - Added `_handleAnalysisError()` method:
    - Logs errors at ERROR level: "Analysis error | profile={profileId} | error={error}"
    - Increments `_healthCheckStats.totalErrors` counter
    - Continues operation - analysis failures don't crash the application
  - Fixed shutdown order:
    - Old: dataLogger → statisticsEngine → alertManager → driveDetector
    - New: dataLogger → alertManager → driveDetector → statisticsEngine
    - DriveDetector may still be triggering analysis at shutdown
  - Updated 2 existing tests that checked old initialization/shutdown order
  - Added 17 new tests covering:
    - StatisticsEngine creation from config
    - Engine receives database reference
    - DriveDetector receives statisticsEngine reference
    - Callback registration with correct method name
    - _handleAnalysisComplete logging and display notification
    - _handleAnalysisError logging and error handling
    - Initialization and shutdown order verification
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - init order, callback registration, error handler)
  - tests/test_orchestrator.py (MODIFIED - 17 new tests, fixed 2 order tests, now 156 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-009 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - StatisticsEngine uses `registerCallbacks()` not `registerCallback()` - check actual method signatures
  - Callback parameter names differ between components: `onComplete` vs `onAnalysisComplete`
  - When testing internal imports in methods, patch at the actual module location (e.g., `obd.statistics_engine.createStatisticsEngineFromConfig` not `obd.orchestrator.createStatisticsEngineFromConfig`)
  - Initialization order matters for dependency injection - components that ARE dependencies must be initialized BEFORE components that NEED those dependencies
  - Shutdown order should allow ongoing operations to complete - driveDetector may trigger analysis, so stop detector before stopping analysis engine
---

## 2026-01-23 - US-OSC-010
User Story: Wire Up Display Manager
- What was implemented:
  - Added missing methods to DisplayManager (src/display/manager.py):
    - `updateValue(paramName, value, unit)` - for realtime dashboard parameter updates
    - `showDriveStatus(status)` - for drive status display ('driving', 'stopped')
    - `showConnectionStatus(status)` - for connection status ('Connected', 'Reconnecting...')
    - `showAnalysisResult(result)` - for statistics analysis completion notification
    - `showWelcomeScreen(appName, version)` - for startup welcome screen
    - `showShutdownMessage()` - for shutdown display message
    - `stop()` - alias for shutdown() for orchestrator compatibility
  - Updated `_initializeDisplayManager()` in orchestrator.py:
    - Calls `initialize()` on display manager after creation
    - Shows welcome screen via `showWelcomeScreen()` on successful init
    - Logs display mode on startup (headless/minimal/developer)
  - Added `_createHeadlessDisplayFallback()` method:
    - Creates headless display manager when hardware unavailable
    - Falls back gracefully without crashing application
  - Updated `_shutdownDisplayManager()`:
    - Shows 'Shutting down...' message before stopping display
  - Added 20 new tests covering all acceptance criteria:
    - Display manager created from config
    - Display mode selection (headless, minimal, developer)
    - Display initialized on startup with welcome screen
    - Status updates (connection, drive status, alerts, values, analysis)
    - Shutdown message display
    - Graceful fallback to headless
    - updateValue method for dashboard params
    - DisplayManager.stop() method exists
- Files changed:
  - src/display/manager.py (MODIFIED - added 7 new methods, ~120 lines)
  - src/obd/orchestrator.py (MODIFIED - updated _initializeDisplayManager and _shutdownDisplayManager, added _createHeadlessDisplayFallback)
  - tests/test_orchestrator.py (MODIFIED - added 20 new tests, now 176 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-010 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - DisplayManager methods should delegate to driver methods with hasattr() checks for graceful handling
  - When patching local imports in methods, patch at the actual import module (e.g., `obd.display_manager.createDisplayManagerFromConfig` not `obd.orchestrator.createDisplayManagerFromConfig`)
  - Display fallback should create a new config dict with 'mode': 'headless' to ensure proper headless initialization
  - Orchestrator's _stopComponentWithTimeout expects a `stop()` method - add it as alias for `shutdown()` for consistency
  - Welcome screen should be called AFTER successful initialize() to ensure display is ready
---

## 2026-01-23 - US-OSC-011
User Story: Wire Up Profile System
- What was implemented:
  - Added ProfileSwitcher component to ApplicationOrchestrator:
    - `_profileSwitcher` component reference
    - `profileSwitcher` property for external access
    - `_initializeProfileSwitcher()` creates switcher wired to profileManager, driveDetector, displayManager, database
    - `_shutdownProfileSwitcher()` for graceful cleanup
    - Updated getStatus() to include profileSwitcher status
  - Added `_handleProfileChange(oldProfileId, newProfileId)` callback:
    - Updates AlertManager thresholds via `setProfileThresholds()` and `setActiveProfile()`
    - Updates DataLogger polling interval via `setPollingInterval()`
    - Logs profile change at INFO level: "Profile changed from {old} to {new}"
  - Wired ProfileSwitcher.onProfileChange() in `_setupComponentCallbacks()`
  - Updated initialization order: profileSwitcher initialized after driveDetector (needs drive state)
  - Updated shutdown order: profileSwitcher shutdown before profileManager
  - Exported `createProfileSwitcherFromConfig` from obd.profile_manager module
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - added ~100 lines for profile switcher wiring)
  - src/obd/profile_manager.py (MODIFIED - added createProfileSwitcherFromConfig export)
  - tests/test_orchestrator.py (MODIFIED - added 15 new tests, now 191 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-011 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - ProfileSwitcher handles drive-aware switching - queues profile change if driving, activates on drive start
  - When patching imports inside methods, patch at actual import location (e.g., `obd.profile_manager.createProfileSwitcherFromConfig` not `obd.orchestrator.createProfileSwitcherFromConfig`)
  - AlertManager uses `setProfileThresholds(profileId, thresholds)` and `setActiveProfile(profileId)` methods
  - RealtimeDataLogger uses `setPollingInterval(intervalMs)` method (minimum 100ms)
  - Profile.alertThresholds is a dict with keys like 'rpmRedline', 'coolantTempCritical'
  - Profile.pollingIntervalMs is the polling interval in milliseconds
---

## 2026-01-23 - US-OSC-012
User Story: Implement Connection Recovery
- What was implemented:
  - Added automatic connection recovery to ApplicationOrchestrator
  - Connection loss detection triggers automatic reconnection
  - Exponential backoff retry delays: [1, 2, 4, 8, 16] seconds (configurable via config['bluetooth']['retryDelays'])
  - Maximum retry attempts: 5 (configurable via config['bluetooth']['maxRetries'])
  - Added new constants:
    - DEFAULT_CONNECTION_CHECK_INTERVAL = 5.0 seconds
    - DEFAULT_RECONNECT_DELAYS = [1, 2, 4, 8, 16]
    - DEFAULT_MAX_RECONNECT_ATTEMPTS = 5
  - Added state tracking:
    - _isReconnecting: bool flag for reconnection in progress
    - _reconnectAttempt: current retry attempt number
    - _dataLoggerPausedForReconnect: bool for data logger pause state
    - _reconnectThread: background thread for reconnection
  - New methods implemented:
    - _startReconnection(): Initiates background reconnection thread
    - _reconnectionLoop(): Main reconnection loop with exponential backoff
    - _attemptReconnection(): Single reconnection attempt using connection.reconnect() or disconnect()+connect()
    - _handleReconnectionSuccess(): Updates state, resumes logging, notifies display
    - _handleReconnectionFailure(): Logs error, updates state, allows system to continue
    - _pauseDataLogging(): Stops data logger during reconnection
    - _resumeDataLogging(): Restarts data logger after successful reconnection
  - Updated _handleConnectionLost() to set status to 'reconnecting' and call _startReconnection()
  - Updated __all__ exports to include new constants
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - added ~260 lines for connection recovery)
  - tests/test_orchestrator.py (MODIFIED - added 35 new tests, now 226 total)
  - tests/test_orchestrator_integration.py (MODIFIED - updated test expectation for 'reconnecting' status)
  - ralph/prd.json (MODIFIED - marked US-OSC-012 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Connection recovery runs in a background daemon thread to avoid blocking the main loop
  - Use small sleep increments (0.1s) during backoff wait to allow for shutdown cancellation
  - ObdConnection has a reconnect() method that handles disconnect + connect internally
  - When connection is lost, status should be 'reconnecting' not 'disconnected' to indicate recovery in progress
  - Data logger should be stopped during reconnection to avoid errors from failed queries
  - The reconnection loop should check shutdownState to allow clean shutdown during recovery
  - Background threads should be daemon threads so they don't block application exit
---

## 2026-01-23 - US-OSC-013
User Story: Implement First-Connection VIN Decode
- What was implemented:
  - Added `_performFirstConnectionVinDecode()` method to ApplicationOrchestrator
  - Method queries VIN from vehicle via `connection.obd.query("VIN")`
  - Checks if VIN is cached in database via `vinDecoder.isVinCached(vin)`
  - If cached, retrieves from cache via `vinDecoder.getDecodedVin(vin)`
  - If not cached, decodes via NHTSA API via `vinDecoder.decodeVin(vin)`
  - Logs vehicle info on startup: "Connected to [Year] [Make] [Model]"
  - Stores VIN in `_vehicleVin` property for reference
  - Added `_displayVehicleInfo()` method with fallback to showConnectionStatus
  - Added `showVehicleInfo()` method to DisplayManager
  - VIN decode called from `_initializeAllComponents()` after vinDecoder initialization
  - API timeout and errors handled gracefully (application continues without decode)
  - Subsequent connections use cached data (checked via isVinCached)
- Files changed:
  - src/obd/orchestrator.py (MODIFIED - added ~100 lines for VIN decode methods)
  - src/display/manager.py (MODIFIED - added showVehicleInfo method)
  - tests/test_orchestrator.py (MODIFIED - added 17 new tests, now 243 total)
  - ralph/prd.json (MODIFIED - marked US-OSC-013 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - VIN decode must happen AFTER vinDecoder is initialized, so call from _initializeAllComponents not _initializeConnection
  - Use hasattr() checks for obd interface: `hasattr(self._connection, 'obd') and self._connection.obd is not None`
  - VIN response uses `is_null()` method to check for null/unavailable response
  - Display fallback pattern: try showVehicleInfo first, fall back to showConnectionStatus
  - Exception handling wraps all external calls (VIN query, cache check, decode, display) for graceful degradation
  - VinDecodeResult has `getVehicleSummary()` method that returns formatted string "Year Make Model"
---

## 2026-01-23 - US-OSC-016
User Story: Create systemd Service File
- What was implemented:
  - Created `deploy/eclipse-obd.service` systemd unit file
    - Type: simple - main process is Python application
    - Restart: on-failure with 10 second delay
    - After: network.target, bluetooth.target for proper startup ordering
    - Wants: bluetooth.target to ensure Bluetooth is ready
    - User: configurable (default: pi)
    - WorkingDirectory: configurable (default: /home/pi/obd2)
    - Environment: PATH includes virtual environment
    - Logs to files in logs/ directory
    - StartLimitBurst: 5 attempts in 5 minutes
  - Created `deploy/install-service.sh` installation script
    - Supports --user and --path command line options
    - Validates user exists and installation path exists
    - Checks for virtual environment and main.py
    - Creates logs/ and data/ directories with proper ownership
    - Copies and modifies service file with sed for path substitution
    - Enables service for auto-start on boot
    - Provides helpful post-install commands
  - Created `deploy/uninstall-service.sh` removal script
    - Stops service if running
    - Disables auto-start
    - Removes service file
    - Optional --keep-logs flag to preserve log files
    - Resets systemd failed state
  - Updated `docs/deployment-checklist.md` with:
    - Quick installation using install script
    - Manual installation steps
    - Service management commands (start/stop/restart/status)
    - Log viewing commands (journalctl and file-based)
    - Uninstallation instructions
    - Service configuration details explanation
- Files changed:
  - deploy/eclipse-obd.service (NEW - 68 lines)
  - deploy/install-service.sh (NEW - 179 lines)
  - deploy/uninstall-service.sh (NEW - 113 lines)
  - docs/deployment-checklist.md (MODIFIED - updated Priority 4 section with detailed instructions)
  - ralph/prd.json (MODIFIED - marked US-OSC-016 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - systemd service files should use `After=` for dependencies that must be ready, `Wants=` for soft dependencies
  - RestartSec should be long enough for Bluetooth to stabilize (10s recommended for OBD-II dongles)
  - Use StartLimitBurst to prevent infinite restart loops on persistent failures
  - Shell scripts should use `set -e` for fail-fast behavior
  - sed -i for in-place file modifications works well for service file customization
  - Color codes (RED/GREEN/YELLOW/NC) improve shell script user experience
  - Always validate prerequisites (user exists, path exists, venv exists) before installation
  - Service logs should go to both journal (default) and file (for easier debugging)
---

## 2026-01-23 - US-OSC-017
User Story: Create Production Environment Template
- What was implemented:
  - Created `.env.production.example` with comprehensive documentation for Raspberry Pi deployment
  - Environment variables documented with comments:
    - APP_ENVIRONMENT: Environment mode (development, staging, production)
    - DB_PATH: SQLite database file path with recommended Pi location
    - OBD_BT_MAC: Bluetooth dongle MAC address with detailed discovery instructions
    - DISPLAY_MODE: Display output mode (headless, minimal, developer)
    - LOG_LEVEL: Log verbosity level (DEBUG, INFO, WARNING, ERROR)
    - LOG_FILE: Log file path with log rotation guidance
    - EXPORT_DIR: CSV export directory
    - AI_MODEL: Optional Ollama model for AI analysis
    - AI_PROMPT_TEMPLATE: Optional custom AI prompt
  - Detailed instructions for finding OBD-II dongle MAC address using bluetoothctl
  - Display mode options documented with descriptions and use cases:
    - headless: No display, logging only (recommended for background service)
    - minimal: Adafruit 1.3" 240x240 TFT display (ST7789)
    - developer: Detailed console output for debugging
  - Recommended production values summary section
  - Troubleshooting section covering Bluetooth, permissions, display, and database issues
- Files changed:
  - .env.production.example (NEW - 180 lines)
  - ralph/prd.json (MODIFIED - marked US-OSC-017 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Environment templates should include HOW TO comments for non-obvious values (like MAC address discovery)
  - Document all valid options for enum-like values (display modes, log levels)
  - Include a recommended values summary section for quick copy-paste deployment
  - Troubleshooting section helps users self-diagnose common issues
  - Reference related documentation files (bluetooth-setup.md, deployment-checklist.md) for detailed procedures
---

## 2026-01-23 - US-OSC-018
User Story: Create Hardware Verification Script
- What was implemented:
  - Created `scripts/verify_hardware.py` with HardwareVerifier class
  - Implemented hardware verification checks:
    - Python version check >= 3.11 (critical - required for app to run)
    - SQLite version and in-memory connectivity test (critical)
    - Bluetooth adapter detection via systemctl/hciconfig/bluetoothctl on Linux
    - OBD-II dongle discovery with optional --mac parameter for paired device check
    - Display hardware check (--display flag) for Adafruit board/ST7789/Pillow
    - GPIO access check (--gpio flag) for RPi.GPIO and /sys/class/gpio sysfs
  - Clear PASS/FAIL output with ANSI color coding (green/red/yellow/blue)
  - Exit code 0 if all critical checks pass, 1 otherwise
  - Cross-platform support - Linux-specific checks skip gracefully on Windows/Mac
  - Helpful error messages with installation instructions for missing dependencies
  - Command-line arguments: --mac, --display, --gpio
- Files changed:
  - scripts/verify_hardware.py (NEW - 617 lines)
  - ralph/prd.json (MODIFIED - marked US-OSC-018 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 task)
- **Learnings for future iterations:**
  - Use ANSI escape codes for terminal colors: Colors class with GREEN, RED, YELLOW, BLUE, RESET, BOLD
  - Critical vs non-critical checks: critical checks determine exit code, non-critical just warn
  - Bluetooth detection on Linux: try systemctl first, then hciconfig, then bluetoothctl as fallbacks
  - Adafruit `board` module raises NotImplementedError on non-RPi - catch multiple exception types
  - Use subprocess.run with capture_output=True, text=True, timeout=5 for shell commands
  - Platform checks: platform.system() returns 'Linux', 'Windows', 'Darwin'
  - Follow existing script patterns in the codebase (check_platform.py) for consistency
---

## 2026-01-23 - US-OSC-019
User Story: Create Bluetooth Pairing Documentation
- What was implemented:
  - Created comprehensive `docs/bluetooth-setup.md` with step-by-step OBD-II Bluetooth dongle pairing guide
  - Section 1: Finding dongle MAC address with `bluetoothctl scan on`
    - Includes preparation steps (vehicle ignition, dongle initialization)
    - Lists common dongle names (OBDII, ELM327, Vgate, OBDLink)
    - Shows expected scan output examples
  - Section 2: Pairing procedure with `bluetoothctl pair`
    - Includes common default PIN codes (1234, 0000, 6789)
    - Documents troubleshooting for failed pairing
  - Section 3: Trust device for auto-reconnect with `bluetoothctl trust`
    - Critical for automatic application startup
  - Section 4: Verification with device info
    - Shows how to verify Paired, Trusted, and UUID: Serial Port status
  - Section 5: Verification with rfcomm
    - Documents `rfcomm bind` command for serial port creation
    - Shows test with `screen` command
  - Section 6: Verification with python-OBD
    - Complete test script included
    - Shows expected output for engine on/off states
  - Section 7: Application configuration
    - Documents .env file MAC address setting
    - References verify_hardware.py for validation
  - Troubleshooting section covers 9 common issues:
    - Dongle not appearing in scan
    - Pairing fails
    - Connection drops
    - Cannot create rfcomm device
    - python-OBD connection fails
    - Permission denied
    - Bluetooth service not running
  - Quick reference section with common commands
- Files changed:
  - docs/bluetooth-setup.md (NEW - 550+ lines)
  - ralph/prd.json (MODIFIED - marked US-OSC-019 as passes: true)
  - ralph/ralph_agents.json (MODIFIED - updated Agent1 status)
- **Learnings for future iterations:**
  - Documentation files should reference related docs (deployment-checklist.md, testing.md, .env.production.example)
  - Include expected output for ALL commands - helps users verify they're on track
  - Common OBD-II dongle PIN codes: 1234 (90%), 0000, 6789, 1111
  - bluetoothctl is the standard Bluetooth tool on Linux, preferred over hcitool/rfcomm
  - Trust is critical for auto-reconnect - often overlooked in Bluetooth setup guides
  - python-OBD can connect directly via MAC address, not just rfcomm device
  - Document troubleshooting BEFORE problems occur - saves users time
---

