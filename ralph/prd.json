{
  "project": "Eclipse OBD-II Raspberry Pi Hardware Integration",
  "branchName": "ralph/rpi-hardware-integration",
  "description": "Document target hardware and implement Pi-specific modules for UPS monitoring, display, and power management",
  "userStories": [
    {
      "id": "US-RPI-001",
      "title": "Create Hardware Reference Documentation",
      "description": "As a developer, I want hardware specifications documented in the codebase so that I understand the target platform constraints.",
      "acceptanceCriteria": [
        "Create docs/hardware-reference.md with component specs (Pi 5, X1209 UPS, OSOYOO display)",
        "Document I2C addresses (0x36 or 0x57 for X1209) and telemetry data points",
        "Document GPIO pin assignments for shutdown button and status LED",
        "Include text-based wiring/connection diagram",
        "Reference the detailed specs in specs/samples/piSpecs.md",
        "Typecheck passes"
      ],
      "priority": "high",
      "passes": true,
      "notes": "Completed 2026-01-25. Created docs/hardware-reference.md with Pi 5 specs, X1209 UPS HAT specs, I2C config (bus 1, 0x36/0x57), telemetry data points, GPIO assignments (GPIO17 button, GPIO27 LED), OSOYOO display specs, wiring diagram, and platform-specific code guidance.",
      "dependencies": []
    },
    {
      "id": "US-RPI-002",
      "title": "Verify OBD2 Module Compatibility with Raspberry Pi",
      "description": "As a developer, I want to verify the existing OBD2 code runs on Raspberry Pi so that we can deploy to the target hardware.",
      "acceptanceCriteria": [
        "Review existing OBD2 modules for Pi compatibility issues",
        "Document any platform-specific code paths needed in docs/hardware-reference.md",
        "Verify obd library supports ARM64/Raspberry Pi OS in requirements.txt",
        "Create requirements-pi.txt with Pi-specific packages (smbus2, RPi.GPIO, gpiozero)",
        "Typecheck passes"
      ],
      "priority": "high",
      "passes": true,
      "notes": "Completed 2026-01-25. Reviewed OBD2 modules - python-OBD is pure Python with pyserial, fully compatible with ARM64. Added OBD2 Module Compatibility section to hardware-reference.md documenting platform support, serial port differences, and simulator mode. Updated requirements-pi.txt with gpiozero and smbus2 (uncommented). Added comprehensive module compatibility matrix. 609 tests pass.",
      "dependencies": ["US-RPI-001"]
    },
    {
      "id": "US-RPI-003",
      "title": "Implement Platform Detection Utility",
      "description": "As a developer, I want to detect whether code is running on Raspberry Pi so that Pi-specific features are only enabled on the target hardware.",
      "acceptanceCriteria": [
        "Create src/hardware/__init__.py with package exports",
        "Create src/hardware/platform_utils.py with platform detection functions",
        "Implement isRaspberryPi() function that returns bool",
        "Implement getPlatformInfo() returning dict with os, architecture, model",
        "Handle graceful fallback on non-Pi systems (return False, don't crash)",
        "Add unit tests in tests/test_platform_utils.py",
        "Follow existing src/common/ patterns and standards",
        "Typecheck passes"
      ],
      "priority": "high",
      "passes": true,
      "notes": "Completed 2026-01-25. Created src/hardware/ package with platform_utils.py. Implemented isRaspberryPi() to detect Pi via /proc/device-tree/model on Linux. Implemented getPlatformInfo() returning dict with os, architecture, model, isRaspberryPi. All functions handle exceptions gracefully (return False/defaults, never crash). Added 18 unit tests covering Pi detection, non-Pi fallback, error handling. 627 tests pass.",
      "dependencies": []
    },
    {
      "id": "US-RPI-004",
      "title": "Create Raspberry Pi Setup Script",
      "description": "As a developer, I want a setup script that configures a fresh Raspberry Pi so that deployment is repeatable and documented.",
      "acceptanceCriteria": [
        "Create scripts/pi_setup.sh for initial system configuration",
        "Enable I2C interface via raspi-config non-interactive mode",
        "Install system dependencies (i2c-tools, python3-smbus)",
        "Install Python dependencies from requirements.txt and requirements-pi.txt",
        "Create required directories (/var/log/carpi/, data/)",
        "Script is idempotent (safe to run multiple times)",
        "Add usage documentation to docs/deployment.md or docs/hardware-reference.md",
        "Typecheck passes"
      ],
      "priority": "high",
      "passes": true,
      "notes": "Completed 2026-01-25. Created scripts/pi_setup.sh with: Pi verification, I2C enabling via raspi-config nonint do_i2c 0, system dependency installation (python3-pip, python3-venv, python3-dev, python3-smbus, i2c-tools, git, build-essential, libffi-dev, libssl-dev), Python dependencies from requirements.txt and requirements-pi.txt in venv, directory creation (/var/log/carpi/, data/), I2C verification with i2cdetect. Script is fully idempotent with checks before each action. Added comprehensive Initial Setup section to docs/hardware-reference.md with usage, what it does, post-setup steps, and troubleshooting table. 627 tests pass.",
      "dependencies": ["US-RPI-002"]
    },
    {
      "id": "US-RPI-005",
      "title": "Implement I2C Communication Module",
      "description": "As a developer, I want an I2C communication module so that we can read telemetry from the X1209 UPS HAT.",
      "acceptanceCriteria": [
        "Create src/hardware/i2c_client.py with I2cClient class",
        "Implement readByte(address, register) and writeByte(address, register, value) methods",
        "Implement readWord(address, register) for 16-bit values",
        "Add retry logic with 3 retries and exponential backoff on I2C errors",
        "Handle I2C not available gracefully (raise clear exception on non-Pi)",
        "Use smbus2 library for I2C operations",
        "Add unit tests with mocked I2C bus in tests/test_i2c_client.py",
        "Follow error classification system (I2C errors are retryable)",
        "Typecheck passes"
      ],
      "priority": "medium",
      "passes": true,
      "notes": "Completed 2026-01-25. Created src/hardware/i2c_client.py with I2cClient class. Implemented readByte(), writeByte(), readWord(), writeWord() methods using smbus2 library. Added retry logic with 3 retries and exponential backoff (1s, 2s, 4s delays). Created custom exceptions: I2cNotAvailableError (raised on non-Pi), I2cCommunicationError (retryable), I2cDeviceNotFoundError (non-retryable errno 6/19/121). Added context manager support. Created 37 unit tests with mocked SMBus covering all error cases and retry logic. 664 tests pass.",
      "dependencies": ["US-RPI-003"]
    },
    {
      "id": "US-RPI-006",
      "title": "Implement UPS Telemetry Module",
      "description": "As a developer, I want to read battery status from the X1209 UPS so that we can monitor power and trigger safe shutdown.",
      "acceptanceCriteria": [
        "Create src/hardware/ups_monitor.py with UpsMonitor class",
        "Implement getBatteryVoltage() returning float in volts",
        "Implement getBatteryCurrent() returning float in mA",
        "Implement getBatteryPercentage() returning int 0-100",
        "Implement getPowerSource() returning 'external' or 'battery'",
        "Implement polling with configurable interval (default 5 seconds)",
        "Emit callback on power source change (external -> battery)",
        "Add configuration options to config schema (hardware.ups section)",
        "Add unit tests with mocked I2C responses in tests/test_ups_monitor.py",
        "Typecheck passes"
      ],
      "priority": "medium",
      "passes": true,
      "notes": "Completed 2026-01-25. Created src/hardware/ups_monitor.py with UpsMonitor class. Implemented getBatteryVoltage() (reads register 0x02, converts mV to V), getBatteryCurrent() (reads register 0x04, handles signed 16-bit), getBatteryPercentage() (reads register 0x06, clamps 0-100), getPowerSource() (reads register 0x08, returns PowerSource enum). Added polling with configurable interval using background daemon thread. Implemented onPowerSourceChange callback for power transitions. Added hardware.ups config defaults (pollInterval=5, shutdownDelay=30, lowBatteryThreshold=10). Created 58 unit tests with mocked I2C client. 722 tests pass.",
      "dependencies": ["US-RPI-005"]
    },
    {
      "id": "US-RPI-007",
      "title": "Implement Graceful Shutdown Handler",
      "description": "As a developer, I want the system to shut down gracefully when car power is lost so that data is not corrupted.",
      "acceptanceCriteria": [
        "Create src/hardware/shutdown_handler.py with ShutdownHandler class",
        "Monitor UPS for power source change to battery via callback",
        "Implement configurable shutdown delay (default 30 seconds)",
        "Cancel pending shutdown if power restored before delay expires",
        "Initiate system shutdown via subprocess call to systemctl poweroff",
        "Log shutdown events with timestamps at INFO level",
        "Handle low battery (<10%) with immediate shutdown",
        "Add unit tests for shutdown logic in tests/test_shutdown_handler.py",
        "Typecheck passes"
      ],
      "priority": "medium",
      "passes": true,
      "notes": "Completed 2026-01-25. Created src/hardware/shutdown_handler.py with ShutdownHandler class. Implemented onPowerSourceChange() callback for UPS integration - schedules shutdown on EXTERNAL->BATTERY, cancels on BATTERY->EXTERNAL. Configurable shutdown delay (default 30s) with threading.Timer. Implemented onLowBattery() for immediate shutdown when percentage <= threshold. System shutdown via subprocess.run(['systemctl', 'poweroff']). All shutdown events logged at INFO level with timestamps. Added registerWithUpsMonitor() and unregisterFromUpsMonitor() helper methods. Properties: shutdownDelay, lowBatteryThreshold, isShutdownPending, timeUntilShutdown. Context manager and close() for lifecycle. Created 45 unit tests with mocked subprocess. 767 tests pass.",
      "dependencies": ["US-RPI-006"]
    },
    {
      "id": "US-RPI-008",
      "title": "Implement GPIO Shutdown Button Handler",
      "description": "As a developer, I want a physical button to trigger safe shutdown so that users can manually power off the system.",
      "acceptanceCriteria": [
        "Create src/hardware/gpio_button.py with GpioButton class",
        "Monitor configurable GPIO pin for button press (default GPIO17)",
        "Debounce button input (ignore presses within 200ms)",
        "Trigger graceful shutdown on long press (3+ seconds)",
        "Short press logs event but does not shutdown",
        "Handle GPIO not available gracefully (log warning on non-Pi)",
        "Use gpiozero library for GPIO operations",
        "Add unit tests with mocked GPIO in tests/test_gpio_button.py",
        "Typecheck passes"
      ],
      "priority": "low",
      "passes": true,
      "notes": "Completed 2026-01-25. Created src/hardware/gpio_button.py with GpioButton class. Uses gpiozero Button with configurable pin (default GPIO17), bounce_time=0.2s (200ms debounce), and hold_time=3.0s (long press). Short press (release before hold) logs INFO and invokes onShortPress callback. Long press (held >= 3s) logs INFO and invokes onLongPress callback for shutdown integration. Handles non-Pi gracefully by checking isRaspberryPi() and catching gpiozero import errors - logs warning and disables GPIO functionality. Added 56 unit tests with mocked GPIO. 839 tests pass.",
      "dependencies": ["US-RPI-003"]
    },
    {
      "id": "US-RPI-009",
      "title": "Add Hardware Configuration to Config System",
      "description": "As a developer, I want hardware settings in the config system so that GPIO pins, I2C addresses, and intervals are configurable.",
      "acceptanceCriteria": [
        "Add hardware section to config validator DEFAULTS",
        "Include hardware.enabled (default true)",
        "Include hardware.i2c.bus (default 1) and hardware.i2c.upsAddress (default 0x36)",
        "Include hardware.gpio.shutdownButton (default 17) and hardware.gpio.statusLed (default 27)",
        "Include hardware.ups.pollInterval (default 5), hardware.ups.shutdownDelay (default 30), hardware.ups.lowBatteryThreshold (default 10)",
        "Include hardware.display.enabled (default true) and hardware.display.refreshRate (default 2)",
        "Update config.example.json with hardware section",
        "Add unit tests for hardware config defaults",
        "Typecheck passes"
      ],
      "priority": "medium",
      "passes": true,
      "notes": "Completed 2026-01-25. Added all hardware config defaults to DEFAULTS dict in config_validator.py: hardware.enabled (True), hardware.i2c.bus (1), hardware.i2c.upsAddress (0x36), hardware.gpio.shutdownButton (17), hardware.gpio.statusLed (27), hardware.ups.pollInterval (5), hardware.ups.shutdownDelay (30), hardware.ups.lowBatteryThreshold (10), hardware.display.enabled (True), hardware.display.refreshRate (2). Created config.example.json with full hardware section. Added 16 unit tests in TestHardwareConfigDefaults class. 783 tests pass.",
      "dependencies": []
    },
    {
      "id": "US-RPI-010",
      "title": "Implement Simple Status Display",
      "description": "As a user, I want to see system status on the touch display so that I know the system is working and can see battery level.",
      "acceptanceCriteria": [
        "Create src/hardware/status_display.py with StatusDisplay class",
        "Display battery percentage and voltage",
        "Display power source (Car / Battery)",
        "Display OBD2 connection status (Connected / Disconnected / Reconnecting)",
        "Display current errors or warnings count",
        "Display system uptime and IP address",
        "Use large readable fonts optimized for 480x320 touch display",
        "Refresh display every 1-2 seconds (configurable)",
        "Handle display not available gracefully (log warning on non-Pi)",
        "Use pygame for rendering",
        "Add unit tests in tests/test_status_display.py",
        "Typecheck passes"
      ],
      "priority": "low",
      "passes": true,
      "notes": "Completed 2026-01-26. Created src/hardware/status_display.py with StatusDisplay class. Uses pygame for rendering with large readable fonts (32pt title, 24pt medium, 18pt small). Displays battery percentage/voltage (color-coded: green>=50%, orange>=20%, red<20%), power source (Car/Battery/Unknown), OBD2 status (Connected/Disconnected/Reconnecting), error/warning count, system uptime (HH:MM:SS), and IP address. Configurable refresh rate (default 2s). Handles non-Pi gracefully by checking isRaspberryPi() and pygame availability. Added pygame>=2.0.0 to requirements-pi.txt. Thread-safe data updates with threading.Lock. Added 67 unit tests covering all functionality. 906 tests pass.",
      "dependencies": ["US-RPI-006", "US-RPI-009"]
    },
    {
      "id": "US-RPI-011",
      "title": "Implement System Telemetry Logging",
      "description": "As a developer, I want system telemetry logged so that we can diagnose issues and track battery health over time.",
      "acceptanceCriteria": [
        "Create src/hardware/telemetry_logger.py with TelemetryLogger class",
        "Log to configurable path (default /var/log/carpi/telemetry.log)",
        "Log fields: timestamp, power_source, battery_v, battery_ma, battery_pct, cpu_temp, disk_free_mb",
        "Log every 10 seconds (configurable via hardware.telemetry.logInterval)",
        "Use Python logging RotatingFileHandler (7 days or 100MB max)",
        "Output in JSON format for easy parsing",
        "Integrate with existing logging patterns from src/common/",
        "Add unit tests in tests/test_telemetry_logger.py",
        "Typecheck passes"
      ],
      "priority": "low",
      "passes": true,
      "notes": "Completed 2026-01-26. Created src/hardware/telemetry_logger.py with TelemetryLogger class. Uses Python logging RotatingFileHandler for JSON output with configurable path (default /var/log/carpi/telemetry.log), interval (default 10s), max size (100MB), and backup count (7). Logs timestamp, power_source, battery_v, battery_ma, battery_pct, cpu_temp (from /sys/class/thermal/thermal_zone0/temp), disk_free_mb (via shutil.disk_usage). Integrates with UpsMonitor via setUpsMonitor(). Background daemon thread for non-blocking operation. Added telemetry config defaults to config_validator.py. Created 57 unit tests. 963 tests pass.",
      "dependencies": ["US-RPI-006"]
    },
    {
      "id": "US-RPI-012",
      "title": "Create Hardware Module Integration",
      "description": "As a developer, I want all hardware modules integrated into the application so they work together on startup.",
      "acceptanceCriteria": [
        "Create src/hardware/hardware_manager.py with HardwareManager class",
        "HardwareManager initializes: UpsMonitor, ShutdownHandler, GpioButton, StatusDisplay, TelemetryLogger",
        "Provide start() and stop() methods for lifecycle management",
        "Wire UpsMonitor power-change callback to ShutdownHandler",
        "Wire UpsMonitor readings to StatusDisplay updates",
        "Skip initialization of unavailable hardware (non-Pi) with warning",
        "Add createHardwareManagerFromConfig() factory function",
        "Export from src/hardware/__init__.py",
        "Add unit tests in tests/test_hardware_manager.py",
        "Typecheck passes"
      ],
      "priority": "low",
      "passes": true,
      "notes": "Completed 2026-01-26. Created src/hardware/hardware_manager.py with HardwareManager class. Initializes all hardware modules: UpsMonitor, ShutdownHandler, GpioButton, StatusDisplay, TelemetryLogger. Provides start()/stop() lifecycle management with thread-safe operations. Wires UpsMonitor->ShutdownHandler for power-loss shutdown, UpsMonitor->StatusDisplay for battery updates, GpioButton->ShutdownHandler for manual shutdown trigger. Background thread updates display with UPS telemetry. Skips unavailable hardware on non-Pi with warnings. createHardwareManagerFromConfig() factory reads all hardware config options. Updated __init__.py exports. Added 28 unit tests. 991 tests pass.",
      "dependencies": ["US-RPI-007", "US-RPI-008", "US-RPI-010", "US-RPI-011"]
    },
    {
      "id": "US-RPI-013",
      "title": "Integrate Hardware Manager with Application Orchestrator",
      "description": "As a developer, I want the hardware manager integrated into the main application so hardware features are available when running on Pi.",
      "acceptanceCriteria": [
        "Update ApplicationOrchestrator to optionally initialize HardwareManager",
        "Only initialize HardwareManager if isRaspberryPi() returns true",
        "Add hardwareManager to orchestrator component list",
        "Wire hardwareManager.start() into startup sequence (after display)",
        "Wire hardwareManager.stop() into shutdown sequence (before display)",
        "Add hardware status to orchestrator.getStatus() output",
        "Add unit tests for orchestrator hardware integration",
        "Typecheck passes"
      ],
      "priority": "low",
      "passes": false,
      "notes": "",
      "dependencies": ["US-RPI-012"]
    }
  ]
}
