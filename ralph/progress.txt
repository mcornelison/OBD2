# Ralph Progress Log
# Project: Eclipse OBD-II Raspberry Pi Hardware Integration
# Branch: ralph/rpi-hardware-integration
# Started: 2026-01-25

## Codebase Patterns
- ConfigValidator uses dot-notation for nested key access (e.g., 'database.server')
- Default values are defined in module-level DEFAULTS dict
- Custom exceptions should include typed field lists for clear debugging
- All modules in src/common/ follow camelCase for functions, PascalCase for classes
- Test files use AAA pattern (Arrange, Act, Assert) with descriptive docstrings
- Use relative imports within subpackages (e.g., `from .types import ...`)
- Use absolute imports across subpackages (e.g., `from src.obd.data.types import ...`)
- Types modules should have no dependencies on other project modules
- Consider using `TYPE_CHECKING` for type hints to avoid runtime circular imports
- Preserve all docstrings and type hints during moves
- Package/module name collision: When foo/ package shadows foo.py module, use importlib.util
- When refactoring modules, test patches must be updated to reference the new module location
- Re-export facades maintain backward compatibility during subpackage refactoring
- OBD2 modules are fully Pi-compatible; python-OBD uses pyserial (pure Python)
- Adafruit board raises NotImplementedError on non-Pi (catch along with ImportError)
- Platform detection: Check OS first (platform.system()) before file operations
- /proc/device-tree/model contains null bytes - strip with .strip('\x00')
- Hardware modules should return safe defaults on exceptions (False/Unknown)
- Bash Pi scripts: Use raspi-config nonint do_i2c 0 to enable I2C (0=enable, 1=disable)
- Bash Pi scripts: cat /proc/device-tree/model | tr -d '\0' to strip null bytes
- Bash idempotent checks: dpkg -l | grep "^ii  $pkg " for package install check

## Session Log

## 2026-01-25 - US-RPI-001
User Story: Create Hardware Reference Documentation
- Created docs/hardware-reference.md with comprehensive hardware specifications
- Documented Raspberry Pi 5 specs (8GB, ARM64, key interfaces)
- Documented Geekworm X1209 UPS HAT specs (5.1V/5A output, 18650 battery, I2C telemetry)
- Added I2C configuration section (bus 1, addresses 0x36/0x57)
- Documented telemetry data points with register addresses (voltage, current, percentage, power source)
- Added GPIO pin assignments (GPIO17 for shutdown button, GPIO27 for status LED)
- Documented OSOYOO 3.5" HDMI capacitive touch display (480x320, USB touch)
- Created text-based wiring diagram showing all connections
- Added platform-specific code path guidance for Windows vs Pi development
- Referenced specs/samples/piSpecs.md for detailed specifications
- All 609 tests pass
- **Learnings for future iterations:**
  - I2C on Pi uses bus 1 by default (/dev/i2c-1)
  - X1209 can use address 0x36 or 0x57 depending on variant
  - GPIO17/27 are commonly used for button/LED as they're easily accessible
  - Use smbus2 for I2C, gpiozero for GPIO (simpler than RPi.GPIO)
  - Design display UI for 480x320 with large touch targets (60x60px min)
---

## 2026-01-25 - US-RPI-002
User Story: Verify OBD2 Module Compatibility with Raspberry Pi
- Reviewed all OBD2 modules in src/obd/ for Pi compatibility
- Verified python-OBD library is pure Python with pyserial - fully ARM64 compatible
- Added comprehensive OBD2 Module Compatibility section to docs/hardware-reference.md:
  - Platform support matrix (Windows, Raspberry Pi OS, macOS)
  - Serial port differences between platforms
  - Library details (obd>=0.7.1, pyserial dependency)
  - Simulator mode documentation for development without hardware
- Updated requirements-pi.txt:
  - Added gpiozero>=2.0.0 (high-level GPIO interface)
  - Uncommented and enabled smbus2>=0.4.0 (I2C for X1209 UPS)
- Created comprehensive Module Compatibility Matrix in hardware-reference.md
- Added Adafruit display graceful fallback documentation
- All 609 tests pass
- **Learnings for future iterations:**
  - python-OBD is pure Python - no compiled extensions, works on ARM64
  - pyserial handles platform-specific serial port creation automatically
  - Use MAC address in config - library handles /dev/rfcomm0 vs COM port mapping
  - SimulatedObdConnection allows full development/testing on Windows
  - Adafruit board module raises NotImplementedError (not ImportError) on non-Pi
---

## 2026-01-25 - US-RPI-003
User Story: Implement Platform Detection Utility
- Created src/hardware/ package with __init__.py exporting isRaspberryPi, getPlatformInfo
- Created src/hardware/platform_utils.py with platform detection functions
- Implemented isRaspberryPi() that:
  - Checks platform.system() == 'Linux' first (fast fail on Windows/Mac)
  - Reads /proc/device-tree/model to detect Raspberry Pi hardware
  - Returns False gracefully on any error (file not found, read error, exception)
- Implemented getPlatformInfo() returning dict with:
  - os: Operating system name
  - architecture: CPU architecture
  - model: Raspberry Pi model string (or None)
  - isRaspberryPi: Boolean detection result
- All functions handle exceptions gracefully - never crash on non-Pi systems
- Added 18 unit tests covering:
  - Pi detection on Linux with valid model file
  - Non-Pi Linux systems (no "Raspberry Pi" in model)
  - Windows/macOS graceful fallback (return False)
  - File not found, IOError, unexpected exceptions
  - getPlatformInfo with correct return types
  - Integration test ensuring isRaspberryPi matches getPlatformInfo['isRaspberryPi']
- All 627 tests pass (609 existing + 18 new)
- **Learnings for future iterations:**
  - Platform detection should check OS first (platform.system()) before file operations
  - /proc/device-tree/model contains null bytes - strip with .strip('\x00')
  - Always return safe defaults on exceptions in platform detection (False/Unknown)
  - Use mock_open with patch for testing file reads
  - Test both file content and file access exceptions separately
---

## 2026-01-25 - US-RPI-004
User Story: Create Raspberry Pi Setup Script
- Created scripts/pi_setup.sh for initial Raspberry Pi system configuration
- Implemented Pi verification: checks /proc/device-tree/model for "Raspberry Pi"
- Enabled I2C via raspi-config nonint do_i2c 0 (non-interactive mode)
- Installed system dependencies:
  - python3-pip, python3-venv, python3-dev (Python toolchain)
  - python3-smbus (I2C Python bindings)
  - i2c-tools (I2C diagnostic utilities - i2cdetect)
  - git, build-essential, libffi-dev, libssl-dev (build dependencies)
- Created virtual environment in PROJECT_ROOT/.venv
- Installed Python dependencies from requirements.txt and requirements-pi.txt
- Created required directories:
  - /var/log/carpi/ (system log directory for telemetry)
  - data/ (project data directory)
- Set ownership/permissions for created directories to the invoking user
- Added I2C verification: scans for X1209 UPS HAT at addresses 0x36 or 0x57
- Script is fully idempotent - checks before each action, safe to run multiple times
- Added comprehensive documentation to docs/hardware-reference.md:
  - Initial Setup section with usage instructions
  - What the script does (7 steps)
  - Post-setup steps (reboot, activate venv, run verification, start app)
  - Troubleshooting table for common issues
- All 627 tests pass
- **Learnings for future iterations:**
  - Bash scripts on Pi should always check for root privileges (EUID -ne 0)
  - Use `cat /proc/device-tree/model | tr -d '\0'` to strip null bytes in bash
  - raspi-config nonint do_i2c 0 enables I2C (0 = enable, 1 = disable)
  - I2C device appears at /dev/i2c-1 after enabling (may require reboot)
  - Use SUDO_USER to find the actual user when running as root
  - apt-get install -y -qq for quiet, non-interactive installs
  - dpkg -l | grep "^ii  $pkg " to check if package is installed
---

