# Ralph Progress Log
# Project: Eclipse OBD-II Raspberry Pi Hardware Integration
# Branch: ralph/rpi-hardware-integration
# Started: 2026-01-25

## Codebase Patterns
- ConfigValidator uses dot-notation for nested key access (e.g., 'database.server')
- Default values are defined in module-level DEFAULTS dict
- Custom exceptions should include typed field lists for clear debugging
- All modules in src/common/ follow camelCase for functions, PascalCase for classes
- Test files use AAA pattern (Arrange, Act, Assert) with descriptive docstrings
- Use relative imports within subpackages (e.g., `from .types import ...`)
- Use absolute imports across subpackages (e.g., `from src.obd.data.types import ...`)
- Types modules should have no dependencies on other project modules
- Consider using `TYPE_CHECKING` for type hints to avoid runtime circular imports
- Preserve all docstrings and type hints during moves
- Package/module name collision: When foo/ package shadows foo.py module, use importlib.util
- When refactoring modules, test patches must be updated to reference the new module location
- Re-export facades maintain backward compatibility during subpackage refactoring
- OBD2 modules are fully Pi-compatible; python-OBD uses pyserial (pure Python)
- Adafruit board raises NotImplementedError on non-Pi (catch along with ImportError)
- Platform detection: Check OS first (platform.system()) before file operations
- /proc/device-tree/model contains null bytes - strip with .strip('\x00')
- Hardware modules should return safe defaults on exceptions (False/Unknown)
- Bash Pi scripts: Use raspi-config nonint do_i2c 0 to enable I2C (0=enable, 1=disable)
- Bash Pi scripts: cat /proc/device-tree/model | tr -d '\0' to strip null bytes
- Bash idempotent checks: dpkg -l | grep "^ii  $pkg " for package install check
- I2C OSError errno 121 = Remote I/O (device not found), 6 = ENXIO, 19 = ENODEV - don't retry
- Use patch.dict('sys.modules', {'smbus2': mockModule}) to mock hardware library imports
- I2C clients should use context manager pattern for automatic bus cleanup
- Check isRaspberryPi() before opening I2C bus to fail fast on non-Pi systems
- UPS current register uses signed 16-bit: if raw > 32767, subtract 65536 for negative
- Background polling threads should use daemon=True to not block app exit
- Use threading.Event.wait(timeout) instead of time.sleep for clean thread interruption
- Polling loop callbacks should catch exceptions to prevent thread crash
- Lazy hardware initialization allows object creation on non-Pi for testing/mocking
- threading.Timer is simpler than Thread + Event for delayed execution with daemon=True
- __del__ must check hasattr for lock/state attributes since may be called on partially init objects
- subprocess.run() with capture_output=True captures stdout/stderr for error logging

## Session Log

## 2026-01-25 - US-RPI-001
User Story: Create Hardware Reference Documentation
- Created docs/hardware-reference.md with comprehensive hardware specifications
- Documented Raspberry Pi 5 specs (8GB, ARM64, key interfaces)
- Documented Geekworm X1209 UPS HAT specs (5.1V/5A output, 18650 battery, I2C telemetry)
- Added I2C configuration section (bus 1, addresses 0x36/0x57)
- Documented telemetry data points with register addresses (voltage, current, percentage, power source)
- Added GPIO pin assignments (GPIO17 for shutdown button, GPIO27 for status LED)
- Documented OSOYOO 3.5" HDMI capacitive touch display (480x320, USB touch)
- Created text-based wiring diagram showing all connections
- Added platform-specific code path guidance for Windows vs Pi development
- Referenced specs/samples/piSpecs.md for detailed specifications
- All 609 tests pass
- **Learnings for future iterations:**
  - I2C on Pi uses bus 1 by default (/dev/i2c-1)
  - X1209 can use address 0x36 or 0x57 depending on variant
  - GPIO17/27 are commonly used for button/LED as they're easily accessible
  - Use smbus2 for I2C, gpiozero for GPIO (simpler than RPi.GPIO)
  - Design display UI for 480x320 with large touch targets (60x60px min)
---

## 2026-01-25 - US-RPI-002
User Story: Verify OBD2 Module Compatibility with Raspberry Pi
- Reviewed all OBD2 modules in src/obd/ for Pi compatibility
- Verified python-OBD library is pure Python with pyserial - fully ARM64 compatible
- Added comprehensive OBD2 Module Compatibility section to docs/hardware-reference.md:
  - Platform support matrix (Windows, Raspberry Pi OS, macOS)
  - Serial port differences between platforms
  - Library details (obd>=0.7.1, pyserial dependency)
  - Simulator mode documentation for development without hardware
- Updated requirements-pi.txt:
  - Added gpiozero>=2.0.0 (high-level GPIO interface)
  - Uncommented and enabled smbus2>=0.4.0 (I2C for X1209 UPS)
- Created comprehensive Module Compatibility Matrix in hardware-reference.md
- Added Adafruit display graceful fallback documentation
- All 609 tests pass
- **Learnings for future iterations:**
  - python-OBD is pure Python - no compiled extensions, works on ARM64
  - pyserial handles platform-specific serial port creation automatically
  - Use MAC address in config - library handles /dev/rfcomm0 vs COM port mapping
  - SimulatedObdConnection allows full development/testing on Windows
  - Adafruit board module raises NotImplementedError (not ImportError) on non-Pi
---

## 2026-01-25 - US-RPI-003
User Story: Implement Platform Detection Utility
- Created src/hardware/ package with __init__.py exporting isRaspberryPi, getPlatformInfo
- Created src/hardware/platform_utils.py with platform detection functions
- Implemented isRaspberryPi() that:
  - Checks platform.system() == 'Linux' first (fast fail on Windows/Mac)
  - Reads /proc/device-tree/model to detect Raspberry Pi hardware
  - Returns False gracefully on any error (file not found, read error, exception)
- Implemented getPlatformInfo() returning dict with:
  - os: Operating system name
  - architecture: CPU architecture
  - model: Raspberry Pi model string (or None)
  - isRaspberryPi: Boolean detection result
- All functions handle exceptions gracefully - never crash on non-Pi systems
- Added 18 unit tests covering:
  - Pi detection on Linux with valid model file
  - Non-Pi Linux systems (no "Raspberry Pi" in model)
  - Windows/macOS graceful fallback (return False)
  - File not found, IOError, unexpected exceptions
  - getPlatformInfo with correct return types
  - Integration test ensuring isRaspberryPi matches getPlatformInfo['isRaspberryPi']
- All 627 tests pass (609 existing + 18 new)
- **Learnings for future iterations:**
  - Platform detection should check OS first (platform.system()) before file operations
  - /proc/device-tree/model contains null bytes - strip with .strip('\x00')
  - Always return safe defaults on exceptions in platform detection (False/Unknown)
  - Use mock_open with patch for testing file reads
  - Test both file content and file access exceptions separately
---

## 2026-01-25 - US-RPI-004
User Story: Create Raspberry Pi Setup Script
- Created scripts/pi_setup.sh for initial Raspberry Pi system configuration
- Implemented Pi verification: checks /proc/device-tree/model for "Raspberry Pi"
- Enabled I2C via raspi-config nonint do_i2c 0 (non-interactive mode)
- Installed system dependencies:
  - python3-pip, python3-venv, python3-dev (Python toolchain)
  - python3-smbus (I2C Python bindings)
  - i2c-tools (I2C diagnostic utilities - i2cdetect)
  - git, build-essential, libffi-dev, libssl-dev (build dependencies)
- Created virtual environment in PROJECT_ROOT/.venv
- Installed Python dependencies from requirements.txt and requirements-pi.txt
- Created required directories:
  - /var/log/carpi/ (system log directory for telemetry)
  - data/ (project data directory)
- Set ownership/permissions for created directories to the invoking user
- Added I2C verification: scans for X1209 UPS HAT at addresses 0x36 or 0x57
- Script is fully idempotent - checks before each action, safe to run multiple times
- Added comprehensive documentation to docs/hardware-reference.md:
  - Initial Setup section with usage instructions
  - What the script does (7 steps)
  - Post-setup steps (reboot, activate venv, run verification, start app)
  - Troubleshooting table for common issues
- All 627 tests pass
- **Learnings for future iterations:**
  - Bash scripts on Pi should always check for root privileges (EUID -ne 0)
  - Use `cat /proc/device-tree/model | tr -d '\0'` to strip null bytes in bash
  - raspi-config nonint do_i2c 0 enables I2C (0 = enable, 1 = disable)
  - I2C device appears at /dev/i2c-1 after enabling (may require reboot)
  - Use SUDO_USER to find the actual user when running as root
  - apt-get install -y -qq for quiet, non-interactive installs
  - dpkg -l | grep "^ii  $pkg " to check if package is installed
---

## 2026-01-25 - US-RPI-005
User Story: Implement I2C Communication Module
- Created src/hardware/i2c_client.py with I2cClient class
- Implemented I2C read/write methods:
  - readByte(address, register) - reads single byte
  - writeByte(address, register, value) - writes single byte
  - readWord(address, register) - reads 16-bit word
  - writeWord(address, register, value) - writes 16-bit word
- Added retry logic with exponential backoff:
  - 3 retries maximum (4 total attempts)
  - Initial delay: 1.0 seconds
  - Backoff multiplier: 2.0 (delays: 1s, 2s, 4s)
- Created custom I2C exceptions:
  - I2cError (base class with address/register formatting)
  - I2cNotAvailableError (raised on non-Pi or missing smbus2)
  - I2cCommunicationError (retryable errors)
  - I2cDeviceNotFoundError (errno 6/19/121 - no retry)
- Added context manager support for automatic resource cleanup
- Added isConnected property and close() method
- Updated src/hardware/__init__.py to export I2C classes
- Created 37 unit tests in tests/test_i2c_client.py:
  - Exception tests (formatting, inheritance)
  - Initialization tests (non-Pi, missing smbus2, bus errors)
  - Read tests (success, retry, device not found)
  - Write tests (success, retry, value validation)
  - Lifecycle tests (close, context manager)
  - Retry logic tests (exponential backoff, no retry on device not found)
- All 664 tests pass (627 existing + 37 new)
- **Learnings for future iterations:**
  - smbus2 uses little-endian byte order for word operations (SMBus standard)
  - OSError errno 121 = Remote I/O error (device not found), errno 6 = ENXIO, errno 19 = ENODEV
  - Device not found errors should NOT be retried (won't help)
  - Use patch.dict('sys.modules', {'smbus2': mockModule}) to mock imports
  - Context manager pattern (__enter__/__exit__) is preferred for I2C bus management
  - Always check isRaspberryPi() before trying to open I2C bus
  - Value validation before I2C write prevents hardware issues
---

## 2026-01-25 - US-RPI-006
User Story: Implement UPS Telemetry Module
- Created src/hardware/ups_monitor.py with UpsMonitor class
- Implemented telemetry reading methods:
  - getBatteryVoltage() - reads register 0x02, converts mV to volts
  - getBatteryCurrent() - reads register 0x04, handles signed 16-bit conversion
  - getBatteryPercentage() - reads register 0x06, clamps to 0-100 range
  - getPowerSource() - reads register 0x08, returns PowerSource enum
  - getTelemetry() - reads all values in single call
- Added PowerSource enum with EXTERNAL, BATTERY, UNKNOWN values
- Implemented polling with configurable interval:
  - startPolling(interval) starts background daemon thread
  - stopPolling() safely stops polling
  - Uses threading.Event for clean shutdown
- Added onPowerSourceChange callback for power transitions:
  - Invoked when power source changes (external -> battery or vice versa)
  - Exception in callback is caught and logged (doesn't crash polling)
- Created custom exceptions: UpsMonitorError, UpsNotAvailableError
- Added context manager support for automatic resource cleanup
- Added hardware.ups config defaults to config_validator.py:
  - hardware.enabled (True), hardware.i2c.bus (1), hardware.i2c.upsAddress (0x36)
  - hardware.ups.pollInterval (5), hardware.ups.shutdownDelay (30)
  - hardware.ups.lowBatteryThreshold (10)
- Updated src/hardware/__init__.py to export UPS classes
- Created 58 unit tests in tests/test_ups_monitor.py:
  - Exception tests (inheritance, messages)
  - Constants tests (register addresses, defaults)
  - Initialization tests (defaults, custom config, lazy failure)
  - Voltage/current/percentage/power source tests
  - Telemetry aggregation tests
  - Polling tests (start, stop, thread lifecycle)
  - Callback tests (invocation, no change, exception handling)
  - Properties tests (address, bus, pollInterval, isPolling)
  - Lifecycle tests (close, context manager)
  - Error handling tests (communication errors, unavailable)
- All 722 tests pass (664 existing + 58 new)
- **Learnings for future iterations:**
  - UPS telemetry uses signed 16-bit for current: if value > 32767, subtract 65536
  - Polling should use daemon=True for background threads to not block app exit
  - Use threading.Event.wait(timeout) instead of time.sleep for clean interruption
  - Callback exceptions should be caught in polling loop to prevent thread crash
  - Lazy I2C client initialization allows UpsMonitor creation on non-Pi for testing
  - PowerSource enum with UNKNOWN handles unexpected register values gracefully
  - Always clamp percentage values (0-100) as hardware may return out-of-range
---

## 2026-01-25 - US-RPI-007
User Story: Implement Graceful Shutdown Handler
- Created src/hardware/shutdown_handler.py with ShutdownHandler class
- Implemented power source change handling:
  - onPowerSourceChange(oldSource, newSource) callback for UPS integration
  - Schedules shutdown with configurable delay when switching to BATTERY
  - Cancels pending shutdown when power restored (switch to EXTERNAL)
- Implemented configurable shutdown delay:
  - Default 30 seconds (from hardware.ups.shutdownDelay config)
  - Uses threading.Timer with daemon=True for scheduled execution
  - Thread-safe timer operations with threading.Lock
- Implemented shutdown cancellation:
  - cancelShutdown() method returns True if cancelled, False if nothing pending
  - Power restoration automatically cancels pending shutdown
- Implemented system shutdown:
  - subprocess.run(['systemctl', 'poweroff']) for actual shutdown
  - Error handling for subprocess failures and non-zero return codes
- Implemented low battery handling:
  - onLowBattery(percentage) triggers immediate shutdown if <= threshold
  - Default threshold 10% (from hardware.ups.lowBatteryThreshold config)
- All shutdown events logged at INFO level with timestamps
- Helper methods:
  - registerWithUpsMonitor(monitor) - sets power change callback
  - unregisterFromUpsMonitor(monitor) - clears callback
- Properties: shutdownDelay, lowBatteryThreshold, isShutdownPending, timeUntilShutdown
- Context manager and close() for lifecycle management
- Updated src/hardware/__init__.py to export ShutdownHandler, ShutdownHandlerError
- Created 45 unit tests in tests/test_shutdown_handler.py:
  - Exception tests (inheritance, messages)
  - Constants tests (defaults)
  - Initialization tests (defaults, custom values, validation)
  - Power source change tests (schedule, cancel, edge cases)
  - Low battery tests (threshold behavior)
  - Scheduled shutdown tests (execution, cancellation)
  - UPS integration tests (register/unregister)
  - Property tests (getters, setters, validation)
  - Lifecycle tests (close, context manager)
  - Error handling tests (subprocess failures)
- All 767 tests pass (722 existing + 45 new)
- **Learnings for future iterations:**
  - threading.Timer is simpler than creating Thread + Event for delayed execution
  - Use daemon=True on Timer so it doesn't block app exit
  - Thread-safe operations need Lock protection for timer state
  - __del__ must check hasattr for _lock since it may be called on partially init objects
  - subprocess.run() with capture_output=True captures stdout/stderr for error logging
  - Test patches for subprocess.run work across platforms (Windows/Linux)
  - When testing callbacks, check call_args_list (all calls) not just call_args (last call)
---

